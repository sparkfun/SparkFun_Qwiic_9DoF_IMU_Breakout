<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>InvenSense Device Driver library: data_converter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="invn_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">InvenSense Device Driver library
   &#160;<span id="projectnumber">3.8.9</span>
   </div>
   <div id="projectbrief">Library to control and get data from an InvenSense device (aka libIDD)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00128.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">data_converter</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga996f7be338ccb40d1a2a5abc1ad61759"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga996f7be338ccb40d1a2a5abc1ad61759">ABS</a>(x)&#160;&#160;&#160;(((x)&gt;=0)?(x):-(x))</td></tr>
<tr class="memdesc:ga996f7be338ccb40d1a2a5abc1ad61759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of its argument <em>x</em>.  <a href="#ga996f7be338ccb40d1a2a5abc1ad61759">More...</a><br /></td></tr>
<tr class="separator:ga996f7be338ccb40d1a2a5abc1ad61759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc3ee1a7f283f8ef65cea31f4436a95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#gaacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(x,  y)&#160;&#160;&#160;(((x)&gt;(y))?(x):(y))</td></tr>
<tr class="memdesc:gaacc3ee1a7f283f8ef65cea31f4436a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum of <em>x</em> and <em>y</em>.  <a href="#gaacc3ee1a7f283f8ef65cea31f4436a95">More...</a><br /></td></tr>
<tr class="separator:gaacc3ee1a7f283f8ef65cea31f4436a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e75242132eaabbc1c512488a135926"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga74e75242132eaabbc1c512488a135926">MIN</a>(x,  y)&#160;&#160;&#160;(((x)&lt;(y))?(x):(y))</td></tr>
<tr class="memdesc:ga74e75242132eaabbc1c512488a135926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum of <em>x</em> and <em>y</em>.  <a href="#ga74e75242132eaabbc1c512488a135926">More...</a><br /></td></tr>
<tr class="separator:ga74e75242132eaabbc1c512488a135926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1cb5820f785504ed0e80dc8a8be250"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga8f1cb5820f785504ed0e80dc8a8be250">INVN_FLT_TO_FXP</a>(value,  shift)&#160;&#160;&#160;( (int32_t)  ((float)(value)*(1ULL &lt;&lt; (shift)) + ( (value&gt;=0)-0.5f )) )</td></tr>
<tr class="memdesc:ga8f1cb5820f785504ed0e80dc8a8be250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the <em>value</em> from float to QN value.  <a href="#ga8f1cb5820f785504ed0e80dc8a8be250">More...</a><br /></td></tr>
<tr class="separator:ga8f1cb5820f785504ed0e80dc8a8be250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga536905184e5c4cbb9e028c0380d74839"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga536905184e5c4cbb9e028c0380d74839"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga536905184e5c4cbb9e028c0380d74839">INVN_CONVERT_FLT_TO_FXP</a>(fltptr,  fixptr,  length,  shift)&#160;&#160;&#160;{ int i; for(i=0; i&lt;(length); ++i) (fixptr)[i] = <a class="el" href="a00128.html#ga8f1cb5820f785504ed0e80dc8a8be250">INVN_FLT_TO_FXP</a>((fltptr)[i], shift); }</td></tr>
<tr class="memdesc:ga536905184e5c4cbb9e028c0380d74839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to convert float values from an address into QN values, and copy them to another address. <br /></td></tr>
<tr class="separator:ga536905184e5c4cbb9e028c0380d74839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2b8d98cfb066bf98d61755c844fa8f0a"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga2b8d98cfb066bf98d61755c844fa8f0a">inv_icm20948_q_mult_q_qi</a> (const long *q1, const long *q2, long *qProd)</td></tr>
<tr class="memdesc:ga2b8d98cfb066bf98d61755c844fa8f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a fixed point quaternion multiply with inverse on second element q1*q2'.  <a href="#ga2b8d98cfb066bf98d61755c844fa8f0a">More...</a><br /></td></tr>
<tr class="separator:ga2b8d98cfb066bf98d61755c844fa8f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9792bcfcf1f2fbd10d943f3a15eeaa92"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga9792bcfcf1f2fbd10d943f3a15eeaa92">inv_icm20948_set_chip_to_body</a> (struct <a class="el" href="a00028.html">inv_icm20948</a> *s, long *quat)</td></tr>
<tr class="memdesc:ga9792bcfcf1f2fbd10d943f3a15eeaa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the transformation used for chip to body frame.  <a href="#ga9792bcfcf1f2fbd10d943f3a15eeaa92">More...</a><br /></td></tr>
<tr class="separator:ga9792bcfcf1f2fbd10d943f3a15eeaa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0f50b6fd21ef269a27b1883f77ac23"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga7c0f50b6fd21ef269a27b1883f77ac23">inv_icm20948_convert_rotation_vector</a> (struct <a class="el" href="a00028.html">inv_icm20948</a> *s, const long *quat, float *values)</td></tr>
<tr class="memdesc:ga7c0f50b6fd21ef269a27b1883f77ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts fixed point DMP rotation vector to floating point android notation.  <a href="#ga7c0f50b6fd21ef269a27b1883f77ac23">More...</a><br /></td></tr>
<tr class="separator:ga7c0f50b6fd21ef269a27b1883f77ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e8f22cf2ec8f6c66f9bb1a6513d56a"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga14e8f22cf2ec8f6c66f9bb1a6513d56a">inv_icm20948_convert_rotation_vector_2</a> (struct <a class="el" href="a00028.html">inv_icm20948</a> *s, const long *quat, long *quat4_world)</td></tr>
<tr class="memdesc:ga14e8f22cf2ec8f6c66f9bb1a6513d56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 3 element fixed point DMP rotation vector to 4 element rotation vector in world frame.  <a href="#ga14e8f22cf2ec8f6c66f9bb1a6513d56a">More...</a><br /></td></tr>
<tr class="separator:ga14e8f22cf2ec8f6c66f9bb1a6513d56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1bdec26f558f72c42a3901e81ab74b4"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#gac1bdec26f558f72c42a3901e81ab74b4">inv_icm20948_convert_rotation_vector_3</a> (const long *quat4_world, float *values)</td></tr>
<tr class="memdesc:gac1bdec26f558f72c42a3901e81ab74b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 4 element rotation vector in world frame to floating point android notation.  <a href="#gac1bdec26f558f72c42a3901e81ab74b4">More...</a><br /></td></tr>
<tr class="separator:gac1bdec26f558f72c42a3901e81ab74b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b38e3dec1099d68e0af9ff83807470"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga04b38e3dec1099d68e0af9ff83807470">inv_icm20948_convert_dmp3_to_body</a> (struct <a class="el" href="a00028.html">inv_icm20948</a> *s, const long *vec3, float scale, float *values)</td></tr>
<tr class="memdesc:ga04b38e3dec1099d68e0af9ff83807470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the data in android values.  <a href="#ga04b38e3dec1099d68e0af9ff83807470">More...</a><br /></td></tr>
<tr class="separator:ga04b38e3dec1099d68e0af9ff83807470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9051e759ad4eae0931884ff0ccef7a67"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga9051e759ad4eae0931884ff0ccef7a67">inv_icm20948_set_chip_to_body_axis_quaternion</a> (struct <a class="el" href="a00028.html">inv_icm20948</a> *s, signed char *accel_gyro_matrix, float angle)</td></tr>
<tr class="memdesc:ga9051e759ad4eae0931884ff0ccef7a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the data in android quaternion values.  <a href="#ga9051e759ad4eae0931884ff0ccef7a67">More...</a><br /></td></tr>
<tr class="separator:ga9051e759ad4eae0931884ff0ccef7a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca6ef4101d2440ead77f29ddff25f82"><td class="memItemLeft" align="right" valign="top">unsigned char INV_EXPORT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga6ca6ef4101d2440ead77f29ddff25f82">inv_icm20948_int32_to_little8</a> (long x, unsigned char *little8)</td></tr>
<tr class="memdesc:ga6ca6ef4101d2440ead77f29ddff25f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit long to a little endian byte stream.  <a href="#ga6ca6ef4101d2440ead77f29ddff25f82">More...</a><br /></td></tr>
<tr class="separator:ga6ca6ef4101d2440ead77f29ddff25f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293371f68d5a8397968cd0bebb81b9c3"><td class="memItemLeft" align="right" valign="top">float INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga293371f68d5a8397968cd0bebb81b9c3">inv_icm20948_convert_deg_to_rad</a> (float deg_val)</td></tr>
<tr class="memdesc:ga293371f68d5a8397968cd0bebb81b9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts degree angle to radian.  <a href="#ga293371f68d5a8397968cd0bebb81b9c3">More...</a><br /></td></tr>
<tr class="separator:ga293371f68d5a8397968cd0bebb81b9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7649bd9344876e119c46f8bc5d05d258"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga7649bd9344876e119c46f8bc5d05d258">inv_icm20948_convert_mult_q30_fxp</a> (long a_q30, long b_q30)</td></tr>
<tr class="memdesc:ga7649bd9344876e119c46f8bc5d05d258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiply and shift by 30.  <a href="#ga7649bd9344876e119c46f8bc5d05d258">More...</a><br /></td></tr>
<tr class="separator:ga7649bd9344876e119c46f8bc5d05d258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fac3afc22904fd53d24cae32be26aee"><td class="memItemLeft" align="right" valign="top">int INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga1fac3afc22904fd53d24cae32be26aee">inv_icm20948_convert_compute_scalar_part_fxp</a> (const long *inQuat_q30, long *outQuat_q30)</td></tr>
<tr class="memdesc:ga1fac3afc22904fd53d24cae32be26aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute real part of quaternion, element[0].  <a href="#ga1fac3afc22904fd53d24cae32be26aee">More...</a><br /></td></tr>
<tr class="separator:ga1fac3afc22904fd53d24cae32be26aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0d8b1b447f98ecebf8625774da6b8a"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga2c0d8b1b447f98ecebf8625774da6b8a">inv_icm20948_convert_fast_sqrt_fxp</a> (long x0_q30)</td></tr>
<tr class="memdesc:ga2c0d8b1b447f98ecebf8625774da6b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates square-root of a fixed-point number (30 bit mantissa, positive)  <a href="#ga2c0d8b1b447f98ecebf8625774da6b8a">More...</a><br /></td></tr>
<tr class="separator:ga2c0d8b1b447f98ecebf8625774da6b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a10e6fbd9620e91317cbb857a6fe3a4"><td class="memItemLeft" align="right" valign="top">int INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga0a10e6fbd9620e91317cbb857a6fe3a4">inv_icm20948_convert_test_limits_and_scale_fxp</a> (long *x0_q30, int *pow)</td></tr>
<tr class="memdesc:ga0a10e6fbd9620e91317cbb857a6fe3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function used by inv_OneOverX(), inv_fastSquareRoot(), inv_inverseSqrt().  <a href="#ga0a10e6fbd9620e91317cbb857a6fe3a4">More...</a><br /></td></tr>
<tr class="separator:ga0a10e6fbd9620e91317cbb857a6fe3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d526f3608f1bfaf345b52c99cc3fb2e"><td class="memItemLeft" align="right" valign="top">int16_t INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga6d526f3608f1bfaf345b52c99cc3fb2e">inv_icm20948_convert_get_highest_bit_position</a> (uint32_t *value)</td></tr>
<tr class="memdesc:ga6d526f3608f1bfaf345b52c99cc3fb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function used by testLimitsAndScale() Find the highest nonzero bit in an unsigned 32 bit integer:  <a href="#ga6d526f3608f1bfaf345b52c99cc3fb2e">More...</a><br /></td></tr>
<tr class="separator:ga6d526f3608f1bfaf345b52c99cc3fb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942ea0b3e149d93bde331cc5368ff32c"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga942ea0b3e149d93bde331cc5368ff32c">inv_icm20948_convert_matrix_to_quat_fxp</a> (long *Rcb_q30, long *Qcb_q30)</td></tr>
<tr class="memdesc:ga942ea0b3e149d93bde331cc5368ff32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a rotation matrix to a quaternion.  <a href="#ga942ea0b3e149d93bde331cc5368ff32c">More...</a><br /></td></tr>
<tr class="separator:ga942ea0b3e149d93bde331cc5368ff32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8c5c7e81a824957fbce2b2ece80edb"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga8d8c5c7e81a824957fbce2b2ece80edb">inv_icm20948_convert_sqrt_q30_fxp</a> (long x_q30)</td></tr>
<tr class="memdesc:ga8d8c5c7e81a824957fbce2b2ece80edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates square-root of a fixed-point number.  <a href="#ga8d8c5c7e81a824957fbce2b2ece80edb">More...</a><br /></td></tr>
<tr class="separator:ga8d8c5c7e81a824957fbce2b2ece80edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30269402b4cfefc77cb6d05c45667518"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga30269402b4cfefc77cb6d05c45667518">inv_icm20948_convert_inv_sqrt_q30_fxp</a> (long x_q30, int *pow2)</td></tr>
<tr class="memdesc:ga30269402b4cfefc77cb6d05c45667518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates 1/square-root of a fixed-point number (30 bit mantissa, positive): Q1.30.  <a href="#ga30269402b4cfefc77cb6d05c45667518">More...</a><br /></td></tr>
<tr class="separator:ga30269402b4cfefc77cb6d05c45667518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac879f1432fe2bdf6875247427e482b22"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#gac879f1432fe2bdf6875247427e482b22">inv_icm20948_convert_inverse_q30_fxp</a> (long x_q30, int *pow2)</td></tr>
<tr class="memdesc:gac879f1432fe2bdf6875247427e482b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse function based on Newton-Raphson 1/sqrt(x) calculation.  <a href="#gac879f1432fe2bdf6875247427e482b22">More...</a><br /></td></tr>
<tr class="separator:gac879f1432fe2bdf6875247427e482b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a578d22c17ecf265e8d57df4292f24"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#gab5a578d22c17ecf265e8d57df4292f24">inv_icm20948_convert_matrix_to_quat_flt</a> (float *R, float *q)</td></tr>
<tr class="memdesc:gab5a578d22c17ecf265e8d57df4292f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a rotation matrix to a quaternion in floating point.  <a href="#gab5a578d22c17ecf265e8d57df4292f24">More...</a><br /></td></tr>
<tr class="separator:gab5a578d22c17ecf265e8d57df4292f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6523ae6037245ba4943be1cef67331a5"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga6523ae6037245ba4943be1cef67331a5">inv_icm20948_convert_mult_qfix_fxp</a> (long a, long b, unsigned char qfix)</td></tr>
<tr class="memdesc:ga6523ae6037245ba4943be1cef67331a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiply and shift by shift.  <a href="#ga6523ae6037245ba4943be1cef67331a5">More...</a><br /></td></tr>
<tr class="separator:ga6523ae6037245ba4943be1cef67331a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd62dd50a2fdcbc51e81a2f7349e351b"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#gafd62dd50a2fdcbc51e81a2f7349e351b">inv_icm20948_convert_quat_to_col_major_matrix_fxp</a> (const long *quat_q30, long *rot_q30)</td></tr>
<tr class="memdesc:gafd62dd50a2fdcbc51e81a2f7349e351b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a quaternion to a rotation matrix in column major convention.  <a href="#gafd62dd50a2fdcbc51e81a2f7349e351b">More...</a><br /></td></tr>
<tr class="separator:gafd62dd50a2fdcbc51e81a2f7349e351b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eaddaf9b3bcc31aeb6ab7fdb8615004"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga2eaddaf9b3bcc31aeb6ab7fdb8615004">inv_icm20948_math_atan2_q15_fxp</a> (long y_q15, long x_q15)</td></tr>
<tr class="memdesc:ga2eaddaf9b3bcc31aeb6ab7fdb8615004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seventh order Chebychev polynomial approximation in Q15.  <a href="#ga2eaddaf9b3bcc31aeb6ab7fdb8615004">More...</a><br /></td></tr>
<tr class="separator:ga2eaddaf9b3bcc31aeb6ab7fdb8615004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc0417ff172e13aaacfb0195b04f293"><td class="memItemLeft" align="right" valign="top">uint8_t INV_EXPORT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga1cc0417ff172e13aaacfb0195b04f293">inv_icm20948_convert_int16_to_big8</a> (int16_t x, uint8_t *big8)</td></tr>
<tr class="memdesc:ga1cc0417ff172e13aaacfb0195b04f293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 16-bit short to a big endian byte stream.  <a href="#ga1cc0417ff172e13aaacfb0195b04f293">More...</a><br /></td></tr>
<tr class="separator:ga1cc0417ff172e13aaacfb0195b04f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a88d5567ccf12cf5733b2d40aa20c6f"><td class="memItemLeft" align="right" valign="top">uint8_t INV_EXPORT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga7a88d5567ccf12cf5733b2d40aa20c6f">inv_icm20948_convert_int32_to_big8</a> (int32_t x, uint8_t *big8)</td></tr>
<tr class="memdesc:ga7a88d5567ccf12cf5733b2d40aa20c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit long to a big endian byte stream.  <a href="#ga7a88d5567ccf12cf5733b2d40aa20c6f">More...</a><br /></td></tr>
<tr class="separator:ga7a88d5567ccf12cf5733b2d40aa20c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b136e422c28034a032e04354408aae"><td class="memItemLeft" align="right" valign="top">int32_t INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga65b136e422c28034a032e04354408aae">inv_icm20948_convert_big8_to_int32</a> (const uint8_t *big8)</td></tr>
<tr class="memdesc:ga65b136e422c28034a032e04354408aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a big endian byte stream into a 32-bit long.  <a href="#ga65b136e422c28034a032e04354408aae">More...</a><br /></td></tr>
<tr class="separator:ga65b136e422c28034a032e04354408aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b83087ec9ceeaf916ee5b300be77982"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html#ga0b83087ec9ceeaf916ee5b300be77982">inv_icm20948_convert_quat_rotate_fxp</a> (const long *quat_q30, const long *in, long *out)</td></tr>
<tr class="memdesc:ga0b83087ec9ceeaf916ee5b300be77982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts long values according to quat_30 matrix.  <a href="#ga0b83087ec9ceeaf916ee5b300be77982">More...</a><br /></td></tr>
<tr class="separator:ga0b83087ec9ceeaf916ee5b300be77982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga996f7be338ccb40d1a2a5abc1ad61759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ABS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(((x)&gt;=0)?(x):-(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolute value of its argument <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="ga8f1cb5820f785504ed0e80dc8a8be250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVN_FLT_TO_FXP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">shift&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;( (int32_t)  ((float)(value)*(1ULL &lt;&lt; (shift)) + ( (value&gt;=0)-0.5f )) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the <em>value</em> from float to QN value. </p>

</div>
</div>
<a class="anchor" id="gaacc3ee1a7f283f8ef65cea31f4436a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((x)&gt;(y))?(x):(y))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum of <em>x</em> and <em>y</em>. </p>

</div>
</div>
<a class="anchor" id="ga74e75242132eaabbc1c512488a135926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((x)&lt;(y))?(x):(y))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum of <em>x</em> and <em>y</em>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga65b136e422c28034a032e04354408aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t INV_EXPORT inv_icm20948_convert_big8_to_int32 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>big8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a big endian byte stream into a 32-bit long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">big8</td><td>big endian byte stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>corresponding 32-bit integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1fac3afc22904fd53d24cae32be26aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int INV_EXPORT inv_icm20948_convert_compute_scalar_part_fxp </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>inQuat_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>outQuat_q30</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute real part of quaternion, element[0]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inQuat_q30</td><td>3 elements gyro quaternion. Dimension is 3. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outQuat_q30</td><td>Quaternion. Dimension is 4. 4 elements gyro quaternion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga293371f68d5a8397968cd0bebb81b9c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float INV_EXPORT inv_icm20948_convert_deg_to_rad </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>deg_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts degree angle to radian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deg_val</td><td>the angle in degree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in radian </dd></dl>

</div>
</div>
<a class="anchor" id="ga04b38e3dec1099d68e0af9ff83807470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_convert_dmp3_to_body </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00028.html">inv_icm20948</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the data in android values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec3</td><td>vector of the DMP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>scale calculated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>in Android format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2c0d8b1b447f98ecebf8625774da6b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20948_convert_fast_sqrt_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x0_q30</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates square-root of a fixed-point number (30 bit mantissa, positive) </p>
<p>Input must be a positive scaled ( <img class="formulaInl" alt="$ 2^{30} $" src="form_0.png"/> ) integer The number is scaled to lie between a range in which a Newton-Raphson iteration works best. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x0_q30</td><td>length 1. Fixed point format is Q30 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scaled square root if succeed else 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d526f3608f1bfaf345b52c99cc3fb2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t INV_EXPORT inv_icm20948_convert_get_highest_bit_position </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function used by testLimitsAndScale() Find the highest nonzero bit in an unsigned 32 bit integer: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>operand Dimension is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>highest bit position. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function performs the log2 of an interger as well. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1cc0417ff172e13aaacfb0195b04f293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t INV_EXPORT* inv_icm20948_convert_int16_to_big8 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>big8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 16-bit short to a big endian byte stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>operand </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">big8</td><td>big endian byte stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>big8 pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a88d5567ccf12cf5733b2d40aa20c6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t INV_EXPORT* inv_icm20948_convert_int32_to_big8 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>big8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 32-bit long to a big endian byte stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>operand </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">big8</td><td>big endian byte stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>big8 pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga30269402b4cfefc77cb6d05c45667518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20948_convert_inv_sqrt_q30_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pow2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates 1/square-root of a fixed-point number (30 bit mantissa, positive): Q1.30. </p>
<p>The number is scaled to lie between a range in which a Newton-Raphson iteration works best. Caller must scale final result by 2^rempow (while avoiding overflow). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_q30</td><td>Input. The input must be positive. Fixed point format is Q30. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pow2</td><td>Corresponding square root of the power of two is returned. length 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of x in Q30. </dd></dl>

</div>
</div>
<a class="anchor" id="gac879f1432fe2bdf6875247427e482b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20948_convert_inverse_q30_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pow2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse function based on Newton-Raphson 1/sqrt(x) calculation. </p>
<p>Note that upshifting c (the result) by pow2 right away will overflow q30 if b&lt;0.5 in q30 (=536870912). <br />
 So if you are doing some multiplication later on (like a/b), then it might be better to do <code>q30_mult(a,c)</code> first and then shift it up by pow2: <code>q30_mult(a,c)&lt;&lt;pow2</code> <br />
 The result might still overflow in some cases (large a, small b: a=1073741824, b=1 but precise limits of the overflow are tbd).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_q30</td><td>the operand. Fixed point format is Q30 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pow2</td><td>a power of 2 by which 1/b is downshifted to fit in q30. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 1/x result in Q30 downshifted by pow2. </dd></dl>

</div>
</div>
<a class="anchor" id="gab5a578d22c17ecf265e8d57df4292f24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_convert_matrix_to_quat_flt </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a rotation matrix to a quaternion in floating point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>Rotation matrix in floating point. The First 3 elements of the rotation matrix, represent the first row of the matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>4-element quaternion in floating point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This functions does not retrieve fixed point quaternion anymore. Use a conversion flt_to_fxp. </dd></dl>

</div>
</div>
<a class="anchor" id="ga942ea0b3e149d93bde331cc5368ff32c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_convert_matrix_to_quat_fxp </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>Rcb_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>Qcb_q30</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a rotation matrix to a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Rcb_q30</td><td>Rotation matrix. Fixed point format is Q30. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Qcb_q30</td><td>quaternion related to provided rotation matrix. Vector size is 4. Fixed point format is Q30. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7649bd9344876e119c46f8bc5d05d258"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20948_convert_mult_q30_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b_q30</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a multiply and shift by 30. </p>
<p>These are good functions to write in assembly on with devices with small memory where you want to get rid of the long long which some assemblers don't handle well </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>((long long)a*b)&gt;&gt;30 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6523ae6037245ba4943be1cef67331a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20948_convert_mult_qfix_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>qfix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a multiply and shift by shift. </p>
<p>These are good functions to write in assembly on with devices with small memory where you want to get rid of the long long which some assemblers don't handle well </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First multicand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second multicand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>Shift amount after multiplying </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>((long long)a*b)&gt;&gt;shift </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Same function that invn_math_mult_qfix_fxp. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b83087ec9ceeaf916ee5b300be77982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_convert_quat_rotate_fxp </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts long values according to quat_30 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat_30</td><td>mounting matrix to apply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>long values to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>long values converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="gafd62dd50a2fdcbc51e81a2f7349e351b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_convert_quat_to_col_major_matrix_fxp </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>rot_q30</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a quaternion to a rotation matrix in column major convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat_q30</td><td>4-element quaternion in fixed point. Fixed point format is Q30. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rot_q30</td><td>Rotation matrix in fixed point. One is 2^30. The Rotation matrix multiplied by a 3 element column vector transforms a vector from Body to World. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>output matrix storage is column major. colmajor_convention </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c0f50b6fd21ef269a27b1883f77ac23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_convert_rotation_vector </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00028.html">inv_icm20948</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts fixed point DMP rotation vector to floating point android notation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat</td><td>3 element rotation vector from DMP, missing the scalar part. Converts from Chip frame to World frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>4 element quaternion in Android format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga14e8f22cf2ec8f6c66f9bb1a6513d56a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_convert_rotation_vector_2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00028.html">inv_icm20948</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>quat4_world</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts 3 element fixed point DMP rotation vector to 4 element rotation vector in world frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat</td><td>3 element rotation vector from DMP, missing the scalar part. Converts from Chip frame to World frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quat4_world</td><td>4 element quaternion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac1bdec26f558f72c42a3901e81ab74b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_convert_rotation_vector_3 </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat4_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts 4 element rotation vector in world frame to floating point android notation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat4_world</td><td>4 element rotation vector in World frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>in Android format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8d8c5c7e81a824957fbce2b2ece80edb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20948_convert_sqrt_q30_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x_q30</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates square-root of a fixed-point number. </p>
<p>This code calls 1/sqrt(x) and multiplies result with x, i.e. <img class="formulaInl" alt="$ \sqrt{x}=x*(1/\sqrt{x}) $" src="form_2.png"/> . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_q30</td><td>Input. Fixed point format is Q30 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of x0 in Q30. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a10e6fbd9620e91317cbb857a6fe3a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int INV_EXPORT inv_icm20948_convert_test_limits_and_scale_fxp </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>x0_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function used by inv_OneOverX(), inv_fastSquareRoot(), inv_inverseSqrt(). </p>
<p>Finds the range of the argument, determines the optimal number of Newton-Raphson iterations and . Restrictions: Number is represented as Q1.30. Number is betweeen the range 2&lt;x&lt;=0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x0_q30</td><td>Input length 1. Number is represented as Q30. Number is betweeen the range 2&lt;x&lt;=0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pow</td><td>Corresponding square root of the power of two is returned. length 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of Newton Raphson iterations, x0 scaled between log(2) and log(4) and <img class="formulaInl" alt="$ 2^N $" src="form_1.png"/> scaling (N=pow) </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ca6ef4101d2440ead77f29ddff25f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char INV_EXPORT* inv_icm20948_int32_to_little8 </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>little8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 32-bit long to a little endian byte stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the long to be converted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">little8</td><td>little endian byte converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative value on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2eaddaf9b3bcc31aeb6ab7fdb8615004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20948_math_atan2_q15_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>y_q15</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x_q15</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seventh order Chebychev polynomial approximation in Q15. </p>
<p>Chebychev 7th order polynomial approximation : <br />
 </p><ul>
<li>in fixed point : <img class="formulaInl" alt="$ constA7 = \text{int32}(2^{15}*[0.999133448222780 -0.320533292381664 0.144982490144465,-0.038254464970299]); $" src="form_3.png"/> <br />
 </li>
<li>in float : <img class="formulaInl" alt="$ A = \begin{bmatrix}[0.999133 &amp; -0.320533 &amp; 0.144982 &amp;-0.0382544 \end{bmatrix}); $" src="form_4.png"/> <br />
</li>
</ul>
<p>The related formula is : <br />
 <img class="formulaInl" alt="$ \xi = \begin{cases} |y|/|x| &amp;&amp; \text{in }(0, \pi/4] \\ |x|/|y| &amp;&amp; \text{in } (\pi/4, \pi/2) \end{cases} , \quad Cheb = A(1)*\xi + A(2)*\xi^3 + A(3)*\xi^5 + A(4)*\xi^7 $" src="form_5.png"/></p>
<p>7th Order Accuracy is +/-0.02 degrees (worst case) through entire range (accomplished with scaling). <br />
 This code depends on: reciprocal_fun_q15 , inverse_sqrt_q15 , inv_q15_mult</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y_q15</td><td>first operand of atan2(y, x). Fixed point format is Q15. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_q15</td><td>second operand of atan2(y, x). Fixed point format is Q15. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output angle in radians. Fixed point format is Q15. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b8d98cfb066bf98d61755c844fa8f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_q_mult_q_qi </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>qProd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a fixed point quaternion multiply with inverse on second element q1*q2'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q1</td><td>First Quaternion Multicand, length 4. 1.0 scaled to 2^30 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q2</td><td>Second Quaternion Multicand, length 4. 1.0 scaled to 2^30. Inverse will be take before multiply </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qProd</td><td>Product after quaternion multiply q1*q2'. Length 4. 1.0 scaled to 2^30. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9792bcfcf1f2fbd10d943f3a15eeaa92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_set_chip_to_body </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00028.html">inv_icm20948</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the transformation used for chip to body frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat</td><td>the quaternion used for the transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9051e759ad4eae0931884ff0ccef7a67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20948_set_chip_to_body_axis_quaternion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00028.html">inv_icm20948</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char *&#160;</td>
          <td class="paramname"><em>accel_gyro_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the data in android quaternion values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">accel_gyro_matrix</td><td>vector of the DMP </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angle</td><td>angle calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 28 2017 20:12:52 for InvenSense Device Driver library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
