<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>InvenSense Device Driver library: data_converter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="invn_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">InvenSense Device Driver library
   &#160;<span id="projectnumber">3.8.9</span>
   </div>
   <div id="projectbrief">Library to control and get data from an InvenSense device (aka libIDD)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00116.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">data_converter</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga996f7be338ccb40d1a2a5abc1ad61759"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga996f7be338ccb40d1a2a5abc1ad61759">ABS</a>(x)&#160;&#160;&#160;(((x)&gt;=0)?(x):-(x))</td></tr>
<tr class="memdesc:ga996f7be338ccb40d1a2a5abc1ad61759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of its argument <em>x</em>.  <a href="#ga996f7be338ccb40d1a2a5abc1ad61759">More...</a><br /></td></tr>
<tr class="separator:ga996f7be338ccb40d1a2a5abc1ad61759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc3ee1a7f283f8ef65cea31f4436a95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gaacc3ee1a7f283f8ef65cea31f4436a95">MAX</a>(x,  y)&#160;&#160;&#160;(((x)&gt;(y))?(x):(y))</td></tr>
<tr class="memdesc:gaacc3ee1a7f283f8ef65cea31f4436a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum of <em>x</em> and <em>y</em>.  <a href="#gaacc3ee1a7f283f8ef65cea31f4436a95">More...</a><br /></td></tr>
<tr class="separator:gaacc3ee1a7f283f8ef65cea31f4436a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e75242132eaabbc1c512488a135926"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga74e75242132eaabbc1c512488a135926">MIN</a>(x,  y)&#160;&#160;&#160;(((x)&lt;(y))?(x):(y))</td></tr>
<tr class="memdesc:ga74e75242132eaabbc1c512488a135926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum of <em>x</em> and <em>y</em>.  <a href="#ga74e75242132eaabbc1c512488a135926">More...</a><br /></td></tr>
<tr class="separator:ga74e75242132eaabbc1c512488a135926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1cb5820f785504ed0e80dc8a8be250"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga8f1cb5820f785504ed0e80dc8a8be250">INVN_FLT_TO_FXP</a>(value,  shift)&#160;&#160;&#160;( (int32_t)  ((float)(value)*(1ULL &lt;&lt; (shift)) + ( (value&gt;=0)-0.5f )) )</td></tr>
<tr class="memdesc:ga8f1cb5820f785504ed0e80dc8a8be250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the <em>value</em> from float to QN value.  <a href="#ga8f1cb5820f785504ed0e80dc8a8be250">More...</a><br /></td></tr>
<tr class="separator:ga8f1cb5820f785504ed0e80dc8a8be250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga536905184e5c4cbb9e028c0380d74839"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga536905184e5c4cbb9e028c0380d74839"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga536905184e5c4cbb9e028c0380d74839">INVN_CONVERT_FLT_TO_FXP</a>(fltptr,  fixptr,  length,  shift)&#160;&#160;&#160;{ int i; for(i=0; i&lt;(length); ++i) (fixptr)[i] = <a class="el" href="a00128.html#ga8f1cb5820f785504ed0e80dc8a8be250">INVN_FLT_TO_FXP</a>((fltptr)[i], shift); }</td></tr>
<tr class="memdesc:ga536905184e5c4cbb9e028c0380d74839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to convert float values from an address into QN values, and copy them to another address. <br /></td></tr>
<tr class="separator:ga536905184e5c4cbb9e028c0380d74839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae0b20302d2e576405873dc39f2d50eaa"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gae0b20302d2e576405873dc39f2d50eaa">inv_icm20648_q_mult_q_qi</a> (const long *q1, const long *q2, long *qProd)</td></tr>
<tr class="memdesc:gae0b20302d2e576405873dc39f2d50eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a fixed point quaternion multiply with inverse on second element q1*q2'.  <a href="#gae0b20302d2e576405873dc39f2d50eaa">More...</a><br /></td></tr>
<tr class="separator:gae0b20302d2e576405873dc39f2d50eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa08e74b20897c45c3798420c9f0b6841"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gaa08e74b20897c45c3798420c9f0b6841">inv_icm20648_set_chip_to_body</a> (struct <a class="el" href="a00024.html">inv_icm20648</a> *s, long *quat)</td></tr>
<tr class="memdesc:gaa08e74b20897c45c3798420c9f0b6841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the transformation used for chip to body frame.  <a href="#gaa08e74b20897c45c3798420c9f0b6841">More...</a><br /></td></tr>
<tr class="separator:gaa08e74b20897c45c3798420c9f0b6841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a9b8962c09c34cb016c447b5a63f65"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga70a9b8962c09c34cb016c447b5a63f65">inv_icm20648_convert_rotation_vector</a> (struct <a class="el" href="a00024.html">inv_icm20648</a> *s, const long *quat, float *values)</td></tr>
<tr class="memdesc:ga70a9b8962c09c34cb016c447b5a63f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts fixed point DMP rotation vector to floating point android notation.  <a href="#ga70a9b8962c09c34cb016c447b5a63f65">More...</a><br /></td></tr>
<tr class="separator:ga70a9b8962c09c34cb016c447b5a63f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b3fed2f9efb0ee976948be078ab2785"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga3b3fed2f9efb0ee976948be078ab2785">inv_icm20648_convert_rotation_vector_2</a> (struct <a class="el" href="a00024.html">inv_icm20648</a> *s, const long *quat, long *quat4_world)</td></tr>
<tr class="memdesc:ga3b3fed2f9efb0ee976948be078ab2785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 3 element fixed point DMP rotation vector to 4 element rotation vector in world frame.  <a href="#ga3b3fed2f9efb0ee976948be078ab2785">More...</a><br /></td></tr>
<tr class="separator:ga3b3fed2f9efb0ee976948be078ab2785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1061f9ad36e8cb9138f2afa1fb13eec"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gaf1061f9ad36e8cb9138f2afa1fb13eec">inv_icm20648_convert_rotation_vector_3</a> (const long *quat4_world, float *values)</td></tr>
<tr class="memdesc:gaf1061f9ad36e8cb9138f2afa1fb13eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 4 element rotation vector in world frame to floating point android notation.  <a href="#gaf1061f9ad36e8cb9138f2afa1fb13eec">More...</a><br /></td></tr>
<tr class="separator:gaf1061f9ad36e8cb9138f2afa1fb13eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07532107cca57e9d1f3e15114090e92d"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga07532107cca57e9d1f3e15114090e92d">inv_icm20648_convert_dmp3_to_body</a> (struct <a class="el" href="a00024.html">inv_icm20648</a> *s, const long *vec3, float scale, float *values)</td></tr>
<tr class="memdesc:ga07532107cca57e9d1f3e15114090e92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the data in android values.  <a href="#ga07532107cca57e9d1f3e15114090e92d">More...</a><br /></td></tr>
<tr class="separator:ga07532107cca57e9d1f3e15114090e92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c6bb0fc6565c5807c82ba8ba6024a9b"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga3c6bb0fc6565c5807c82ba8ba6024a9b">inv_icm20648_set_chip_to_body_axis_quaternion</a> (struct <a class="el" href="a00024.html">inv_icm20648</a> *s, signed char *accel_gyro_matrix, float angle)</td></tr>
<tr class="memdesc:ga3c6bb0fc6565c5807c82ba8ba6024a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the data in android quaternion values.  <a href="#ga3c6bb0fc6565c5807c82ba8ba6024a9b">More...</a><br /></td></tr>
<tr class="separator:ga3c6bb0fc6565c5807c82ba8ba6024a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0375992050921625307d3c4088dda5"><td class="memItemLeft" align="right" valign="top">unsigned char INV_EXPORT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga5c0375992050921625307d3c4088dda5">inv_icm20648_int32_to_little8</a> (long x, unsigned char *little8)</td></tr>
<tr class="memdesc:ga5c0375992050921625307d3c4088dda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit long to a little endian byte stream.  <a href="#ga5c0375992050921625307d3c4088dda5">More...</a><br /></td></tr>
<tr class="separator:ga5c0375992050921625307d3c4088dda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3335c9fd8bc564872e52290b19c5d598"><td class="memItemLeft" align="right" valign="top">float INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga3335c9fd8bc564872e52290b19c5d598">inv_icm20648_convert_deg_to_rad</a> (float deg_val)</td></tr>
<tr class="memdesc:ga3335c9fd8bc564872e52290b19c5d598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts degree angle to radian.  <a href="#ga3335c9fd8bc564872e52290b19c5d598">More...</a><br /></td></tr>
<tr class="separator:ga3335c9fd8bc564872e52290b19c5d598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ba55a72585a58320609cc32ad02daf"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga24ba55a72585a58320609cc32ad02daf">inv_icm20648_convert_mult_q30_fxp</a> (long a_q30, long b_q30)</td></tr>
<tr class="memdesc:ga24ba55a72585a58320609cc32ad02daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiply and shift by 30.  <a href="#ga24ba55a72585a58320609cc32ad02daf">More...</a><br /></td></tr>
<tr class="separator:ga24ba55a72585a58320609cc32ad02daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6fda1f2b68bcd1d01ba6827692839ad"><td class="memItemLeft" align="right" valign="top">int INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gaa6fda1f2b68bcd1d01ba6827692839ad">inv_icm20648_convert_compute_scalar_part_fxp</a> (const long *inQuat_q30, long *outQuat_q30)</td></tr>
<tr class="memdesc:gaa6fda1f2b68bcd1d01ba6827692839ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute real part of quaternion, element[0].  <a href="#gaa6fda1f2b68bcd1d01ba6827692839ad">More...</a><br /></td></tr>
<tr class="separator:gaa6fda1f2b68bcd1d01ba6827692839ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cec9a83a5718864c36da35e301aeeab"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga6cec9a83a5718864c36da35e301aeeab">inv_icm20648_convert_fast_sqrt_fxp</a> (long x0_q30)</td></tr>
<tr class="memdesc:ga6cec9a83a5718864c36da35e301aeeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates square-root of a fixed-point number (30 bit mantissa, positive)  <a href="#ga6cec9a83a5718864c36da35e301aeeab">More...</a><br /></td></tr>
<tr class="separator:ga6cec9a83a5718864c36da35e301aeeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162e61cd5b74702b308ce23adecee25e"><td class="memItemLeft" align="right" valign="top">int INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga162e61cd5b74702b308ce23adecee25e">inv_icm20648_convert_test_limits_and_scale_fxp</a> (long *x0_q30, int *pow)</td></tr>
<tr class="memdesc:ga162e61cd5b74702b308ce23adecee25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function used by inv_OneOverX(), inv_fastSquareRoot(), inv_inverseSqrt().  <a href="#ga162e61cd5b74702b308ce23adecee25e">More...</a><br /></td></tr>
<tr class="separator:ga162e61cd5b74702b308ce23adecee25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df471851e3f0f140bbc537f99c074ec"><td class="memItemLeft" align="right" valign="top">int16_t INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga7df471851e3f0f140bbc537f99c074ec">inv_icm20648_convert_get_highest_bit_position</a> (uint32_t *value)</td></tr>
<tr class="memdesc:ga7df471851e3f0f140bbc537f99c074ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function used by testLimitsAndScale() Find the highest nonzero bit in an unsigned 32 bit integer:  <a href="#ga7df471851e3f0f140bbc537f99c074ec">More...</a><br /></td></tr>
<tr class="separator:ga7df471851e3f0f140bbc537f99c074ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf457753aea1ae93a7f322a1a7718a6c6"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gaf457753aea1ae93a7f322a1a7718a6c6">inv_icm20648_convert_matrix_to_quat_fxp</a> (long *Rcb_q30, long *Qcb_q30)</td></tr>
<tr class="memdesc:gaf457753aea1ae93a7f322a1a7718a6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a rotation matrix to a quaternion.  <a href="#gaf457753aea1ae93a7f322a1a7718a6c6">More...</a><br /></td></tr>
<tr class="separator:gaf457753aea1ae93a7f322a1a7718a6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d762c582cd7677e0ad5aa805712a05"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga88d762c582cd7677e0ad5aa805712a05">inv_icm20648_convert_sqrt_q30_fxp</a> (long x_q30)</td></tr>
<tr class="memdesc:ga88d762c582cd7677e0ad5aa805712a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates square-root of a fixed-point number.  <a href="#ga88d762c582cd7677e0ad5aa805712a05">More...</a><br /></td></tr>
<tr class="separator:ga88d762c582cd7677e0ad5aa805712a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab83568b21a1a11d0117836e3a9d5e6a1"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gab83568b21a1a11d0117836e3a9d5e6a1">inv_icm20648_convert_inv_sqrt_q30_fxp</a> (long x_q30, int *pow2)</td></tr>
<tr class="memdesc:gab83568b21a1a11d0117836e3a9d5e6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates 1/square-root of a fixed-point number (30 bit mantissa, positive): Q1.30.  <a href="#gab83568b21a1a11d0117836e3a9d5e6a1">More...</a><br /></td></tr>
<tr class="separator:gab83568b21a1a11d0117836e3a9d5e6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db65ce00940b219c38db4d94199d845"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga3db65ce00940b219c38db4d94199d845">inv_icm20648_convert_inverse_q30_fxp</a> (long x_q30, int *pow2)</td></tr>
<tr class="memdesc:ga3db65ce00940b219c38db4d94199d845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse function based on Newton-Raphson 1/sqrt(x) calculation.  <a href="#ga3db65ce00940b219c38db4d94199d845">More...</a><br /></td></tr>
<tr class="separator:ga3db65ce00940b219c38db4d94199d845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb505648d3a5294a84c073fa6f5eb06"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga9eb505648d3a5294a84c073fa6f5eb06">inv_icm20648_convert_matrix_to_quat_flt</a> (float *R, float *q)</td></tr>
<tr class="memdesc:ga9eb505648d3a5294a84c073fa6f5eb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a rotation matrix to a quaternion in floating point.  <a href="#ga9eb505648d3a5294a84c073fa6f5eb06">More...</a><br /></td></tr>
<tr class="separator:ga9eb505648d3a5294a84c073fa6f5eb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6d3150b39750f9e1ee45c1f55f79a88"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gae6d3150b39750f9e1ee45c1f55f79a88">inv_icm20648_convert_mult_qfix_fxp</a> (long a, long b, unsigned char qfix)</td></tr>
<tr class="memdesc:gae6d3150b39750f9e1ee45c1f55f79a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a multiply and shift by shift.  <a href="#gae6d3150b39750f9e1ee45c1f55f79a88">More...</a><br /></td></tr>
<tr class="separator:gae6d3150b39750f9e1ee45c1f55f79a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21003eebbf71e1dd42f59bc8c2b8c7c"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gae21003eebbf71e1dd42f59bc8c2b8c7c">inv_icm20648_convert_quat_to_col_major_matrix_fxp</a> (const long *quat_q30, long *rot_q30)</td></tr>
<tr class="memdesc:gae21003eebbf71e1dd42f59bc8c2b8c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a quaternion to a rotation matrix in column major convention.  <a href="#gae21003eebbf71e1dd42f59bc8c2b8c7c">More...</a><br /></td></tr>
<tr class="separator:gae21003eebbf71e1dd42f59bc8c2b8c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf738a0add5f8f0c239563ad09ebe953e"><td class="memItemLeft" align="right" valign="top">long INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gaf738a0add5f8f0c239563ad09ebe953e">inv_icm20648_math_atan2_q15_fxp</a> (long y_q15, long x_q15)</td></tr>
<tr class="memdesc:gaf738a0add5f8f0c239563ad09ebe953e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seventh order Chebychev polynomial approximation in Q15.  <a href="#gaf738a0add5f8f0c239563ad09ebe953e">More...</a><br /></td></tr>
<tr class="separator:gaf738a0add5f8f0c239563ad09ebe953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2412466329759f4795871d4801ac62"><td class="memItemLeft" align="right" valign="top">uint8_t INV_EXPORT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#gadd2412466329759f4795871d4801ac62">inv_icm20648_convert_int16_to_big8</a> (int16_t x, uint8_t *big8)</td></tr>
<tr class="memdesc:gadd2412466329759f4795871d4801ac62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 16-bit short to a big endian byte stream.  <a href="#gadd2412466329759f4795871d4801ac62">More...</a><br /></td></tr>
<tr class="separator:gadd2412466329759f4795871d4801ac62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bdcd95cd3fdb556c8e9be9136e1e7eb"><td class="memItemLeft" align="right" valign="top">uint8_t INV_EXPORT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga8bdcd95cd3fdb556c8e9be9136e1e7eb">inv_icm20648_convert_int32_to_big8</a> (int32_t x, uint8_t *big8)</td></tr>
<tr class="memdesc:ga8bdcd95cd3fdb556c8e9be9136e1e7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 32-bit long to a big endian byte stream.  <a href="#ga8bdcd95cd3fdb556c8e9be9136e1e7eb">More...</a><br /></td></tr>
<tr class="separator:ga8bdcd95cd3fdb556c8e9be9136e1e7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca4996b81879b6f8884f44c04a59a8b"><td class="memItemLeft" align="right" valign="top">int32_t INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga6ca4996b81879b6f8884f44c04a59a8b">inv_icm20648_convert_big8_to_int32</a> (const uint8_t *big8)</td></tr>
<tr class="memdesc:ga6ca4996b81879b6f8884f44c04a59a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a big endian byte stream into a 32-bit long.  <a href="#ga6ca4996b81879b6f8884f44c04a59a8b">More...</a><br /></td></tr>
<tr class="separator:ga6ca4996b81879b6f8884f44c04a59a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6335d476cf253073ea6d6c13a0e79200"><td class="memItemLeft" align="right" valign="top">void INV_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html#ga6335d476cf253073ea6d6c13a0e79200">inv_icm20648_convert_quat_rotate_fxp</a> (const long *quat_q30, const long *in, long *out)</td></tr>
<tr class="memdesc:ga6335d476cf253073ea6d6c13a0e79200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts long values according to quat_30 matrix.  <a href="#ga6335d476cf253073ea6d6c13a0e79200">More...</a><br /></td></tr>
<tr class="separator:ga6335d476cf253073ea6d6c13a0e79200"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga996f7be338ccb40d1a2a5abc1ad61759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ABS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(((x)&gt;=0)?(x):-(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolute value of its argument <em>x</em>. </p>

</div>
</div>
<a class="anchor" id="ga8f1cb5820f785504ed0e80dc8a8be250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVN_FLT_TO_FXP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">shift&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;( (int32_t)  ((float)(value)*(1ULL &lt;&lt; (shift)) + ( (value&gt;=0)-0.5f )) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the <em>value</em> from float to QN value. </p>

</div>
</div>
<a class="anchor" id="gaacc3ee1a7f283f8ef65cea31f4436a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((x)&gt;(y))?(x):(y))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum of <em>x</em> and <em>y</em>. </p>

</div>
</div>
<a class="anchor" id="ga74e75242132eaabbc1c512488a135926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((x)&lt;(y))?(x):(y))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum of <em>x</em> and <em>y</em>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6ca4996b81879b6f8884f44c04a59a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t INV_EXPORT inv_icm20648_convert_big8_to_int32 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>big8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a big endian byte stream into a 32-bit long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">big8</td><td>big endian byte stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>corresponding 32-bit integer. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6fda1f2b68bcd1d01ba6827692839ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int INV_EXPORT inv_icm20648_convert_compute_scalar_part_fxp </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>inQuat_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>outQuat_q30</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute real part of quaternion, element[0]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inQuat_q30</td><td>3 elements gyro quaternion. Dimension is 3. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outQuat_q30</td><td>Quaternion. Dimension is 4. 4 elements gyro quaternion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga3335c9fd8bc564872e52290b19c5d598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float INV_EXPORT inv_icm20648_convert_deg_to_rad </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>deg_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts degree angle to radian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deg_val</td><td>the angle in degree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle in radian </dd></dl>

</div>
</div>
<a class="anchor" id="ga07532107cca57e9d1f3e15114090e92d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_convert_dmp3_to_body </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00024.html">inv_icm20648</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the data in android values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec3</td><td>vector of the DMP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>scale calculated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>in Android format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6cec9a83a5718864c36da35e301aeeab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20648_convert_fast_sqrt_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x0_q30</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates square-root of a fixed-point number (30 bit mantissa, positive) </p>
<p>Input must be a positive scaled ( <img class="formulaInl" alt="$ 2^{30} $" src="form_0.png"/> ) integer The number is scaled to lie between a range in which a Newton-Raphson iteration works best. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x0_q30</td><td>length 1. Fixed point format is Q30 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scaled square root if succeed else 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7df471851e3f0f140bbc537f99c074ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t INV_EXPORT inv_icm20648_convert_get_highest_bit_position </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function used by testLimitsAndScale() Find the highest nonzero bit in an unsigned 32 bit integer: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>operand Dimension is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>highest bit position. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function performs the log2 of an interger as well. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd2412466329759f4795871d4801ac62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t INV_EXPORT* inv_icm20648_convert_int16_to_big8 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>big8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 16-bit short to a big endian byte stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>operand </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">big8</td><td>big endian byte stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>big8 pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bdcd95cd3fdb556c8e9be9136e1e7eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t INV_EXPORT* inv_icm20648_convert_int32_to_big8 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>big8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 32-bit long to a big endian byte stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>operand </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">big8</td><td>big endian byte stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>big8 pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gab83568b21a1a11d0117836e3a9d5e6a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20648_convert_inv_sqrt_q30_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pow2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates 1/square-root of a fixed-point number (30 bit mantissa, positive): Q1.30. </p>
<p>The number is scaled to lie between a range in which a Newton-Raphson iteration works best. Caller must scale final result by 2^rempow (while avoiding overflow). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_q30</td><td>Input. The input must be positive. Fixed point format is Q30. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pow2</td><td>Corresponding square root of the power of two is returned. length 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of x in Q30. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3db65ce00940b219c38db4d94199d845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20648_convert_inverse_q30_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pow2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse function based on Newton-Raphson 1/sqrt(x) calculation. </p>
<p>Note that upshifting c (the result) by pow2 right away will overflow q30 if b&lt;0.5 in q30 (=536870912). <br />
 So if you are doing some multiplication later on (like a/b), then it might be better to do <code>q30_mult(a,c)</code> first and then shift it up by pow2: <code>q30_mult(a,c)&lt;&lt;pow2</code> <br />
 The result might still overflow in some cases (large a, small b: a=1073741824, b=1 but precise limits of the overflow are tbd).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_q30</td><td>the operand. Fixed point format is Q30 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pow2</td><td>a power of 2 by which 1/b is downshifted to fit in q30. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 1/x result in Q30 downshifted by pow2. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9eb505648d3a5294a84c073fa6f5eb06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_convert_matrix_to_quat_flt </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a rotation matrix to a quaternion in floating point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>Rotation matrix in floating point. The First 3 elements of the rotation matrix, represent the first row of the matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>4-element quaternion in floating point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This functions does not retrieve fixed point quaternion anymore. Use a conversion flt_to_fxp. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf457753aea1ae93a7f322a1a7718a6c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_convert_matrix_to_quat_fxp </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>Rcb_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>Qcb_q30</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a rotation matrix to a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Rcb_q30</td><td>Rotation matrix. Fixed point format is Q30. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Qcb_q30</td><td>quaternion related to provided rotation matrix. Vector size is 4. Fixed point format is Q30. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga24ba55a72585a58320609cc32ad02daf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20648_convert_mult_q30_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b_q30</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a multiply and shift by 30. </p>
<p>These are good functions to write in assembly on with devices with small memory where you want to get rid of the long long which some assemblers don't handle well </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>((long long)a*b)&gt;&gt;30 </dd></dl>

</div>
</div>
<a class="anchor" id="gae6d3150b39750f9e1ee45c1f55f79a88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20648_convert_mult_qfix_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>qfix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a multiply and shift by shift. </p>
<p>These are good functions to write in assembly on with devices with small memory where you want to get rid of the long long which some assemblers don't handle well </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First multicand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second multicand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>Shift amount after multiplying </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>((long long)a*b)&gt;&gt;shift </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Same function that invn_math_mult_qfix_fxp. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6335d476cf253073ea6d6c13a0e79200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_convert_quat_rotate_fxp </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts long values according to quat_30 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat_30</td><td>mounting matrix to apply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>long values to be converted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>long values converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="gae21003eebbf71e1dd42f59bc8c2b8c7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_convert_quat_to_col_major_matrix_fxp </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>rot_q30</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a quaternion to a rotation matrix in column major convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat_q30</td><td>4-element quaternion in fixed point. Fixed point format is Q30. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rot_q30</td><td>Rotation matrix in fixed point. One is 2^30. The Rotation matrix multiplied by a 3 element column vector transforms a vector from Body to World. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>output matrix storage is column major. colmajor_convention </dd></dl>

</div>
</div>
<a class="anchor" id="ga70a9b8962c09c34cb016c447b5a63f65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_convert_rotation_vector </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00024.html">inv_icm20648</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts fixed point DMP rotation vector to floating point android notation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat</td><td>3 element rotation vector from DMP, missing the scalar part. Converts from Chip frame to World frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>4 element quaternion in Android format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b3fed2f9efb0ee976948be078ab2785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_convert_rotation_vector_2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00024.html">inv_icm20648</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>quat4_world</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts 3 element fixed point DMP rotation vector to 4 element rotation vector in world frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat</td><td>3 element rotation vector from DMP, missing the scalar part. Converts from Chip frame to World frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quat4_world</td><td>4 element quaternion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf1061f9ad36e8cb9138f2afa1fb13eec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_convert_rotation_vector_3 </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>quat4_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts 4 element rotation vector in world frame to floating point android notation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat4_world</td><td>4 element rotation vector in World frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>in Android format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga88d762c582cd7677e0ad5aa805712a05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20648_convert_sqrt_q30_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x_q30</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates square-root of a fixed-point number. </p>
<p>This code calls 1/sqrt(x) and multiplies result with x, i.e. <img class="formulaInl" alt="$ \sqrt{x}=x*(1/\sqrt{x}) $" src="form_2.png"/> . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_q30</td><td>Input. Fixed point format is Q30 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square root of x0 in Q30. </dd></dl>

</div>
</div>
<a class="anchor" id="ga162e61cd5b74702b308ce23adecee25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int INV_EXPORT inv_icm20648_convert_test_limits_and_scale_fxp </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>x0_q30</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function used by inv_OneOverX(), inv_fastSquareRoot(), inv_inverseSqrt(). </p>
<p>Finds the range of the argument, determines the optimal number of Newton-Raphson iterations and . Restrictions: Number is represented as Q1.30. Number is betweeen the range 2&lt;x&lt;=0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x0_q30</td><td>Input length 1. Number is represented as Q30. Number is betweeen the range 2&lt;x&lt;=0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pow</td><td>Corresponding square root of the power of two is returned. length 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of Newton Raphson iterations, x0 scaled between log(2) and log(4) and <img class="formulaInl" alt="$ 2^N $" src="form_1.png"/> scaling (N=pow) </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c0375992050921625307d3c4088dda5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char INV_EXPORT* inv_icm20648_int32_to_little8 </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>little8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 32-bit long to a little endian byte stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the long to be converted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">little8</td><td>little endian byte converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative value on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf738a0add5f8f0c239563ad09ebe953e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long INV_EXPORT inv_icm20648_math_atan2_q15_fxp </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>y_q15</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x_q15</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seventh order Chebychev polynomial approximation in Q15. </p>
<p>Chebychev 7th order polynomial approximation : <br />
 </p><ul>
<li>in fixed point : <img class="formulaInl" alt="$ constA7 = \text{int32}(2^{15}*[0.999133448222780 -0.320533292381664 0.144982490144465,-0.038254464970299]); $" src="form_3.png"/> <br />
 </li>
<li>in float : <img class="formulaInl" alt="$ A = \begin{bmatrix}[0.999133 &amp; -0.320533 &amp; 0.144982 &amp;-0.0382544 \end{bmatrix}); $" src="form_4.png"/> <br />
</li>
</ul>
<p>The related formula is : <br />
 <img class="formulaInl" alt="$ \xi = \begin{cases} |y|/|x| &amp;&amp; \text{in }(0, \pi/4] \\ |x|/|y| &amp;&amp; \text{in } (\pi/4, \pi/2) \end{cases} , \quad Cheb = A(1)*\xi + A(2)*\xi^3 + A(3)*\xi^5 + A(4)*\xi^7 $" src="form_5.png"/></p>
<p>7th Order Accuracy is +/-0.02 degrees (worst case) through entire range (accomplished with scaling). <br />
 This code depends on: reciprocal_fun_q15 , inverse_sqrt_q15 , inv_q15_mult</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y_q15</td><td>first operand of atan2(y, x). Fixed point format is Q15. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_q15</td><td>second operand of atan2(y, x). Fixed point format is Q15. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output angle in radians. Fixed point format is Q15. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0b20302d2e576405873dc39f2d50eaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_q_mult_q_qi </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>qProd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a fixed point quaternion multiply with inverse on second element q1*q2'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q1</td><td>First Quaternion Multicand, length 4. 1.0 scaled to 2^30 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q2</td><td>Second Quaternion Multicand, length 4. 1.0 scaled to 2^30. Inverse will be take before multiply </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qProd</td><td>Product after quaternion multiply q1*q2'. Length 4. 1.0 scaled to 2^30. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa08e74b20897c45c3798420c9f0b6841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_set_chip_to_body </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00024.html">inv_icm20648</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the transformation used for chip to body frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat</td><td>the quaternion used for the transformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3c6bb0fc6565c5807c82ba8ba6024a9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INV_EXPORT inv_icm20648_set_chip_to_body_axis_quaternion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00024.html">inv_icm20648</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char *&#160;</td>
          <td class="paramname"><em>accel_gyro_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the data in android quaternion values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">accel_gyro_matrix</td><td>vector of the DMP </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angle</td><td>angle calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 28 2017 20:12:52 for InvenSense Device Driver library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
